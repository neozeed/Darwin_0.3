/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.1 (the "License").  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *  clock_speed.c - Determine the best guess for the processor and bus
 *                  speed buy using the values returned by run_clock_test.
 *
 *  (c) Apple Computer, Inc. 1998
 *
 *  Writen by:   Josh de Cesare
 *
 */


#include <powermac.h>
#include <machdep/ppc/DeviceTree.h>

// Threshold for bus speed matches.
#define kMaxFreqDiff  (30000)

// prototypes
extern int get_clock_frequency(void);
extern void run_clock_test(void *tmp);
void do_clock_test(void);
void derive_from_of(void);

// This table hold all of the oddball bus speeds
// It does not need to be in order.
static long bus_freq_table[] = {
  41700000, 66820000, 78750000,
  99730000,
  0 };

// This is the structure for the data that get passed to run_clock_test.
struct clock_test_data {
  unsigned int via_addr;
  unsigned int via_ticks;
  unsigned int dec_ticks;
};

// glocal variables to simplify some stuff.
static long cpu_freq, bus_freq, cpu_pll, bus_frac;

// For debugging
// long g_raw_cpu, g_raw_bus;


// DetermineClockSpeeds is called in identify machine.
// It uses the numbers generated by do_clock_test and reports
// the cleaned up values to the rest of the OS.
void DetermineClockSpeeds(void)
{
  if (0 && IsYosemite()) {
    // Trust OF.
    derive_from_of();
  } else {
    // Figure it out, so go do the real work.
    do_clock_test();
  }
  
  // Calculate the cpu speed from the bus speed and pll mode.
  cpu_freq = (bus_freq * cpu_pll) / (2 * bus_frac);
  
  // Report all the interesting numbers.
  powermac_machine_info.cpu_clock_rate_hz = cpu_freq;
  powermac_machine_info.dec_clock_rate_hz = bus_freq / (4 * bus_frac);
  powermac_machine_info.bus_clock_rate_hz = bus_freq / bus_frac;
  powermac_machine_info.bus_clock_rate_hz_num = bus_freq;
  powermac_machine_info.bus_clock_rate_hz_den = bus_frac;
  powermac_machine_info.cpu_pll = cpu_pll;
  
  powermac_info.bus_clock_rate_hz = bus_freq / bus_frac;
}

// do_clock_test uses the number from run_clock_test to
// find a best fit guess for the bus speed.
void do_clock_test(void)
{
  struct clock_test_data clock_test_data;
  long cnt, diff, raw_cpu_freq, raw_bus_freq, tmp_bus_freq,
    last_bus_freq, tries = 10;

  // Save the via addr so the asm part can use it.
  clock_test_data.via_addr = powermac_io_info.via_base_phys;

  // Keep looping until it matches the last try.
  bus_freq = 0;
  do {
    last_bus_freq = bus_freq;
    
    // The the asm part to do the real work.
    run_clock_test((void *)&clock_test_data);
    
    // First find the pll mode.  Allow any integer times two.
    cpu_pll = 10000000 / clock_test_data.dec_ticks;
    cpu_pll = (cpu_pll / 2) + (cpu_pll & 1);
    
    // Using 64 bit math figure out the raw cpu speed.
    // 0x156ABEULL is 1.27655us.
    raw_cpu_freq = 10000000*(1ULL << 40) /
      (clock_test_data.via_ticks * 0x156ABEULL);
    
    // use the pll mode and the raw cpu speed to find the raw bus speed.
    raw_bus_freq = raw_cpu_freq * 2 / cpu_pll;
    
    // for debugging
    //  g_raw_cpu = raw_cpu_freq;
    //  g_raw_bus = raw_bus_freq;
    
    // Look to see if the bus speed is close to n * 0.5 MHz
    tmp_bus_freq = ((raw_bus_freq + 250000) / 500000) * 500000;
    
    diff = tmp_bus_freq - raw_bus_freq;
    if (diff < 0) diff = -diff;
    
    if (diff < kMaxFreqDiff) {
      bus_freq = tmp_bus_freq;
      bus_frac = 1;
      continue;
    }
    
    // Look to see if the bus speed is close to n * 50/3 MHz
    tmp_bus_freq = ((raw_bus_freq * 3 + 25000000) / 50000000) * 50000000;
    
    diff = tmp_bus_freq - raw_bus_freq * 3;
    if (diff < 0) diff = -diff;
    
    if (diff < kMaxFreqDiff * 3) {
      bus_freq = tmp_bus_freq;
      bus_frac = 3;
      continue;
    }
    
    // Look to see if the bus speed is close to one of the
    // speeds in the table.
    cnt = 0;
    bus_freq = 0;
    do {
      diff = bus_freq_table[cnt] - raw_bus_freq;
      if (diff < 0) diff = -diff;

      if (diff < kMaxFreqDiff) {
	bus_freq = bus_freq_table[cnt];
	bus_frac = 1;
	break;
      }
      
      cnt++;
    } while (bus_freq_table[cnt] != 0);

    if (bus_freq != 0) continue;
    
    // Since all else failed return the raw bus speed
    bus_freq = raw_bus_freq;
    bus_frac = 1;
  } while ((bus_freq != last_bus_freq) && tries--);
}


void derive_from_of(void)
{
  DTEntry entry;
  int     *value;
  int     size;
  long    tmp_bus_freq, diff;

  DTFindEntry("device_type", "cpu", &entry);
  DTGetProperty(entry, "clock-frequency", (void **)&value, &size);
  cpu_freq = *value;

  DTGetProperty(entry, "bus-frequency", (void **)&value, &size);
  bus_freq = *value;

  // First Calculate the pll mode.  Allow any integer times two.
  cpu_pll = (4 * cpu_freq) / bus_freq;
  cpu_pll = (cpu_pll / 2) + (cpu_pll & 1);

  // Look to see if the bus speed is close to n * 0.5 MHz
  tmp_bus_freq = ((bus_freq + 250000) / 500000) * 500000;

  diff = tmp_bus_freq - bus_freq;
  if (diff < 0) diff = -diff;
  
  if (diff < kMaxFreqDiff) {
    bus_freq = tmp_bus_freq;
    bus_frac = 1;
    return;
  }
  
  // Look to see if the bus speed is close to n * 50/3 MHz
  tmp_bus_freq = ((bus_freq * 3 + 25000000) / 50000000) * 50000000;
  
  diff = tmp_bus_freq - bus_freq * 3;
  if (diff < 0) diff = -diff;
  
  if (diff < kMaxFreqDiff * 3) {
    bus_freq = tmp_bus_freq;
    bus_frac = 3;
    return;
  }
  
  // Who knows... just set bus_frac = 1 and use it.
  bus_frac = 1;
}

